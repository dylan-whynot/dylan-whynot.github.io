---
title : '设计模式-设计原则'
description: '设计模式的基本设计原则'
date : '2024-01-11T20:46:39+08:00'
author:     'Dylan'
tags:        ['Java','设计模式']
categories:  ['编程']
---
> Christopher Alexander说过：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”.尽管Alexander所指的是城市和建筑模式，但他的思想也同样适用于面向对象设计模式，只是在面向对象的解决方案里，我们用对象和接口代替了墙壁和门窗。两类模式的核心都在于提供了相关问题的解决方案.	

<!--more-->

# 单⼀职责（Single Responsibility Principle）

单⼀职责（SRP）：Single Responsibility Principle，⼀个类只负责完成⼀个职责或者功能。不要设计⼤⽽全的类，要设计粒度⼩、功能单⼀的类。单⼀职责原则是为了实现代码⾼内聚、低耦合，提⾼代码的复⽤性、可读性、可维护性.

单一职责原则是实现**高内聚、低耦合**的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验

部分指导

- 类中的代码⾏数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进⾏拆分
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合⾼内聚、低耦合的设计思想，我们就需要考虑对类进⾏拆分
- 私有⽅法过多，我们就要考虑能否将私有⽅法独⽴到新的类中，设置为 public ⽅法，供更多的类使⽤，从⽽提⾼代码的复⽤性
- ⽐较难给类起⼀个合适名字，很难⽤⼀个业务名词概括，或者只能⽤⼀些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰

- 类中⼤量的⽅法都是集中操作类中的某⼏个属性，⽐如，在 UserInfo 例⼦中，如果⼀半的⽅法都是在操作address 信息，那就可以考虑将这⼏个属性和对应的⽅法拆分出来

# 开闭原则（Open Closed Principle）

开闭原则（OCP）：Open Closed Principle，对扩展开放，对修改关闭。添加⼀个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、⽅法、属性等），⽽⾮修改已有代码（修改模块、类、⽅法、属性等）的⽅式来完成。

关于定义，我们有两点要注意。第⼀点是，开闭原则并不是说完全杜绝修改，⽽是以最⼩的修改代码的代价来完成新功能的开发。第⼆点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能⼜被认定为“扩展”

⽽且，我们要认识到，添加⼀个新功能，不可能任何模块、类、⽅法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做⼀些初始化操作，才能构建成可运⾏的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核⼼、最复杂的那部分逻辑代码满⾜开闭原则。

最合理的做法是，对于⼀些⽐较确定的、短期内可能就会扩展，或者需求改动对代码结构影响⽐较⼤的情况，或者实现成本不⾼的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于⼀些不确定未来是否要⽀持的需求，或者实现起来⽐较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的⽅式来⽀持扩展的需求

## 如何理解

添加⼀个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、⽅法、属性等），⽽⾮修改已有代码（修改模块、类、⽅法、属性等）的⽅式来完成

## 如何做

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考⼀下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最⼩代码改动的情况下，将新的代码灵活地插⼊到扩展点上。很多设计原则、设计思想、设计模式，都是以提⾼代码的扩展性为最终⽬的的

# ⾥式替换（Liskov Substitution Principle）

⾥式替换（LSP）：⼦类对象（object of subtype/derived class）能够替换程序（program）中⽗类对象（object of base/parent class）出现的任何地⽅，并且保证原来程序的逻辑⾏为（behavior）不变及正确性不被破坏。

举例： 是拿⽗类的单元测试去验证⼦类的代码。如果某些单元测试运⾏失败，就有可能说明，⼦类的设计实现没有完全地遵守⽗类的约定，⼦类有可能违背了⾥式替换原则.

**⾥式替换原则是⽤来指导继承关系中⼦类该如何设计的⼀个原则**。理解⾥式替换原则，最核⼼的就是理解“design by contract，按照协议来设计”这⼏个字。⽗类定义了函数的“约定”（或者叫协议），那⼦类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这⾥的约定包括：函数声明要实现的功能；对输⼊、输出、异常的约定；甚⾄包括注释中所罗列的任何特殊说明。

# 接⼝隔离原则（Interface Segregation Principle）

使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。

它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合

# 依赖反转原则（Dependency Inversion Principle）

这个原则是开闭原则的基础，具体内容：针对接口编程，**依赖于抽象而不依赖于具体**。

依赖反转原则（DIP）： Dependency Inversion Principle ⾼层模块（high-level modules）不要依赖低层模块（low-level）。⾼层模块和低层模块应该通过抽象（abstractions）来互相依赖。

抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。  举例Tomcat和Java WebApp，两者都依赖同⼀个“抽象”，也就是 Servlet 规范

依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法



# 迪米特法则(The LeastKnowledge Principle)

**也叫做最小知识原则**  知道的越少越好

一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系

不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接⼝。迪⽶特法则是希望减少类之间的耦合，让类越独⽴越好。每个类都应该少了解系统的其他部分。⼀旦发⽣变化，需要了解这⼀变化的类就会⽐较少

# KISS原则

>  Keep It Simple,Stupid

KISS 原则是保持代码可读和可维护的重要⼿段。KISS 原则中的“简单”并不是以代码⾏数来考量的。代码⾏数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。

# DRY 原则

> Don’t Repeat Yourself

我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执⾏重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。

实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执⾏重复也算是违反 DRY 原则。
